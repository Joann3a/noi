“梦想杯”2017年 江苏省信息与未来小学生夏令营IT小能手程序设计试题
---
#### 随机数生成规则：<br>
试题中的生成数列R定义如下， <br>
整数0<=R1<201701，在输入时给出。<br>
对于i>1, R(i)=(R(i-1)*6807+2831) mod 201701<br>


### 1.龟兔赛跑
兔子又找乌龟来赛跑啦！同样的错误兔子不会犯两次，所以兔子提出赛跑的时候，乌龟觉得很不公平。于是兔子进一步放宽了条件，表示它可以在比赛开始以后先睡t分钟后在开始追乌龟。<br>
乌龟这下没办法确定比赛到底公平不公平了，所以请你来帮忙。假设乌龟每分钟可以跑x米，兔子每分钟跑y米（y>x）。他希望你计算最大的整数赛跑距离（米），满足乌龟能在兔子先睡t分钟的前提下，比兔子跟早或同时到达终点。<br>
输入：三个整数 x,y,t<br>
输出：一个整数，表示要求的最长赛跑距离<br>

#### 测试样例
样例输入： 11,21,7<br>
样例输出：161<br>
数据规模：1<=x<y<=100,t<1000<br>

### 2.密码锁
乌龟给自己的贵重物品上了密码锁。 密码锁上有5个数字拨盘。每个数字拨盘每次向上拨使数字增加1（9向上拨到0），向下拨使数字减少1（0向下拨得到9）。<br>
拨盘上的数字组成一个5位数，只要拨盘上的数字成为素数，密码锁就会被解开。因为乌龟的动作实在太慢，所以它希望你帮它计算如何开锁，使得拨动的次数最少。<br>
输入：一个5位数，表示拨盘的初始数字<br>
输出：一个5位数，表示开启密码锁使用的素数（拨动次数最少）。如果有多组解，输出满足条件的最大数。<br>

#### 测试样例
样例输入：01210<br>
样例输出：01319
 

### 3.房屋积水
乌龟家的屋顶是凹凸不平的，所以每次雨后都会积水。为了知道屋顶是否会在暴雨后塌掉，他把屋顶的形状给了你，希望你帮它计算暴雨后屋顶的积水总量。<br>
乌龟的屋顶由顺次排列在同一个水平线上的n个宽度为1，高度为整数（分别给出）的瓦片组成。例如给定n=5,瓦片高度分别为4,2,3,5，1。屋顶可以画在如图所示的网格中，灰色格子为瓦片。<br>
				
				
				
				
				

暴雨过后，如果一个方格向左右两边延伸都能达到瓦片占据的方格，它就会积水。所以图中黑色格子在暴雨后会积水。屋顶的积水方格总数为3.<br>
输入：两个整数n,R1,表示屋顶的宽度和生成数列的首项。从左向右数第i(1<=i<=n)个瓦片的高度a(i)=R(i)mod 10<br>
输出：一个整数，表示暴雨后屋顶积水方格的总数。<br>

#### 测试样例
样例输入：10,1<br>
样例输出：23<br>
数据规模：1<=n<=100<br>

### 4.	任务调度
乌龟因为动作太慢，有n个任务已经超过截止日期了。乌龟处理第i个任务需要a(i)单位时间。从0时刻开始，乌龟可以选择某项任务，完成它，然后再开始另一项任务，如此往复知道所有的任务都完成。<br>
由于已经超过截止日期，乌龟会为此受到惩罚，惩罚值等于所有任务完成时刻之和。例如，有2个任务分别需要10和20的单位时间来完成。如果先完成任务1，惩罚值为10+30=40。如果先完成任务2，惩罚值为20+30=50。
乌龟需要你求出惩罚值最小的完成任务的顺序。<br>
输入：两个整数n和R1,标识任务的数量和生成数列的首项。处理任务i（1<=i<=n）的时间a(i)=(R(i) mod 100)+1。<br>
输出：一个整数，标识完成所有任务的最小惩罚值<br>

#### 测试样例
样例输入： 10,2<br>
样例输出： 1641<br>

数据规模： 1<=n<=1000<br>
 

### 5.	基因组分析
乌龟得到了它的基因组，一个只包含“ATCG”四个字母的字符串。乌龟想起科学家说，基因组中很多片段都多次重复出现，而且这种重复是有意义的，于是他想计算一下自己基因组里片段的重复情况。<br>
给定一个基因组，其中一个长度为k的子串称为一个“k-片段”。乌龟希望你计算出基因组中不同的k-片段数量。例如基因组“TACAC”的2-片段有“TA”、“AC”、“CA”、“AC”,其中不同的片段数量有3个。<br>
输入：整数n、k、R1，表示基因组的长度、片段的长度和数列生成的首项。基因组第i（1<=i<=n）个字符在R(i) mod 4的值为0,1,2,3时，分别为A,T,C,G<br>
输出：一个整数，表示不同的k-片段的数量<br>

#### 测试样例
样例输入：20,2,37<br>
样例输出：10<br>
数据规模：30%的数据满足n<=100;100%的数据满足1<=n<=10^5,1<=k<=10<br>

### 6.	加强版密码锁
乌龟偶然得到一个宝箱，宝箱上又有一个密码锁。密码锁由n个拨盘组成，每个拨盘初始时有一个0到99之间的整数。向上拨使数字x变成（x+1）mod 100,向下拨使x变成（x+99）mod 100。<br>
因为密码锁年久失修，拨盘拨动的次数越多越费力。如果一个拨盘被拨动k次，需要花费k^2单位时间。<br>
密码锁只有在所有的拨盘上的数字形成一个从左到右严格递增的数列时才能解开。乌龟再次请你帮忙，求解开密码锁需要的最小时间。<br>
输入：两个整数n,R1,表示拨盘的数量和数列生成的首项。从左向右数第i（1<=i<=n）个拨盘的初始数字为R(i) mod 100<br>
输出：一个整数，表示解开密码锁需要的最小时间。<br>

#### 测试样例
样例输入：10,4<br>
样例输出：3338<br>
数据规模：30%的数据满足n<=3,所有数据满足1<=n<=100<br>

